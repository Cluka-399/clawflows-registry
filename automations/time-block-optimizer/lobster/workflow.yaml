# Lobster workflow: time-block-optimizer
# Analyzes calendar events and finds optimal meeting-free focus blocks
#
# Usage:
#   lobster run --file workflow.yaml --args-json '{"events_file":"/path/to/events.json"}'
#   lobster run --file workflow.yaml --args-json '{"calendar_cmd":"gcalcli agenda --nocolor today tomorrow","work_start":"09:00","work_end":"18:00"}'
#
# events.json: [{"start":"09:00","end":"10:00","title":"Standup"},{"start":"14:00","end":"15:30","title":"Design Review"}]
#
# Requires: jq

name: time-block-optimizer
description: Analyze calendar patterns and suggest optimal meeting-free blocks

args:
  events_file:
    description: "Path to events JSON (alternative to calendar_cmd)"
    default: "/tmp/clawflows-events.json"
  calendar_cmd:
    description: "Shell command to fetch today's calendar events"
    default: ""
  work_start:
    description: "Work day start time (HH:MM)"
    default: "09:00"
  work_end:
    description: "Work day end time (HH:MM)"
    default: "18:00"
  min_block_min:
    description: "Minimum useful focus block in minutes"
    default: "30"

steps:
  - id: load-events
    command: |
      if [ -n "${calendar_cmd}" ]; then
        eval "${calendar_cmd}" 2>/dev/null > /tmp/lb_cal_raw.txt || true
        if [ -s /tmp/lb_cal_raw.txt ]; then
          cat /tmp/lb_cal_raw.txt
        fi
        rm -f /tmp/lb_cal_raw.txt
      fi
      if [ ! -f "${events_file}" ]; then
        printf '[{"start":"09:00","end":"09:30","title":"Daily Standup"},{"start":"10:00","end":"11:00","title":"Sprint Planning"},{"start":"11:30","end":"12:00","title":"1:1 with Manager"},{"start":"13:00","end":"13:30","title":"Lunch & Learn"},{"start":"15:00","end":"16:00","title":"Design Review"},{"start":"16:30","end":"17:00","title":"Quick Sync"}]' > "${events_file}"
        echo "Created sample events at ${events_file}"
      else
        echo "Using events from ${events_file}"
      fi

  - id: compute-blocks
    command: |
      # Convert events to minute-based intervals, find gaps
      jq -c --arg ws "${work_start}" --arg we "${work_end}" --argjson mb ${min_block_min} '
        def to_min: split(":") | (.[0]|tonumber)*60 + (.[1]|tonumber);
        def fmt(m): "\(m / 60 | floor):\(m % 60 | tostring | if length < 2 then "0"+. else . end)";

        ($ws | to_min) as $wstart |
        ($we | to_min) as $wend |

        # Sort and convert to intervals
        [.[] | {s: (.start|to_min), e: (.end|to_min), title}] | sort_by(.s) |

        # Merge overlapping meetings into busy blocks
        reduce .[] as $evt (
          [];
          if length == 0 then [$evt]
          elif .[-1].e >= $evt.s then .[-1].e = ([.[-1].e, $evt.e] | max)
          else . + [$evt]
          end
        ) | . as $busy |

        # Build boundaries: work_start, (busy_end, busy_start)..., work_end
        ([$wstart] + [$busy[] | .s, .e] + [$wend]) |

        # Pair up: free blocks are (busy_end â†’ next_busy_start)
        # Indices: 0=wstart, then pairs of (busy_start, busy_end), then wend
        # Free slots: wstartâ†’first_busy_start, busy1_endâ†’busy2_start, ..., last_busy_endâ†’wend
        . as $pts |
        [range(0; ($busy|length)+1) |
          (if . == 0 then $wstart else $busy[.-1].e end) as $from |
          (if . == ($busy|length) then $wend else $busy[.].s end) as $to |
          select(($to - $from) >= $mb) |
          {start: fmt($from), end: fmt($to), duration_min: ($to - $from)}
        ] | . as $blocks |

        # Stats from original (unsorted) events
        ([$busy[] | .e - .s] | add // 0) as $mtg_min |
        {
          total_events: ($busy | length),
          meeting_hours: ($mtg_min / 60 * 10 | round / 10),
          work_hours: (($wend - $wstart) / 60),
          free_hours: (($wend - $wstart - $mtg_min) / 60 * 10 | round / 10),
          meeting_pct: (if ($wend - $wstart) > 0 then ($mtg_min * 100 / ($wend - $wstart) | round) else 0 end),
          focus_blocks: $blocks,
          best_block: ($blocks | sort_by(-.duration_min) | first // null)
        }
      ' "${events_file}" > /tmp/lb_blocks.json
      # Re-add event titles for display
      jq -c '.' "${events_file}" > /tmp/lb_evts_raw.json
      jq -c --slurpfile evts /tmp/lb_evts_raw.json '. + {events: $evts[0]}' /tmp/lb_blocks.json
      rm -f /tmp/lb_evts_raw.json

  - id: llm_schedule
    stdin: $compute-blocks.stdout
    command: |
      cat > /tmp/lb_tbo_llm.json
      DATA=$(cat /tmp/lb_tbo_llm.json)
      llm_task.invoke <<PROMPT
      You are a time management expert. Given this calendar analysis:

      $DATA

      Provide:
      - block_assignments: suggest what type of work fits each focus block (deep work, admin, creative)
      - async_candidates: meetings that could probably be async (with reasoning)
      - schedule_tweaks: 2-3 adjustments for better flow and fewer context switches
      - deep_work_score: rate this schedule 1-10 for deep work friendliness
      - maker_vs_manager: assessment of schedule type and recommendations

      Return JSON with those fields.
      PROMPT
      rm -f /tmp/lb_tbo_llm.json
    env:
      CLAWD_URL: "http://localhost:1691"

  - id: report
    stdin: $compute-blocks.stdout
    command: |
      cat > /tmp/lb_rpt.json
      LLM_DATA='${{ steps.llm_schedule.stdout }}'
      jq -r '
        "â° Time Block Analysis\n" +
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n" +
        "ðŸ“Š Overview\n" +
        "  Meetings: \(.total_events) blocks (\(.meeting_hours)h / \(.work_hours)h = \(.meeting_pct)%)\n" +
        "  Free time: \(.free_hours)h\n\n" +
        "ðŸ“… Events:\n" +
        (.events | map("  \(.start)-\(.end) \(.title)") | join("\n")) +
        "\n\nðŸŸ¢ Focus Blocks (â‰¥${min_block_min}min):\n" +
        if (.focus_blocks | length) == 0 then "  âš ï¸ No focus blocks available!"
        else (.focus_blocks | map("  \(.start)-\(.end) (\(.duration_min)min)") | join("\n")) end +
        (if .best_block then "\n\nâ­ Best block: \(.best_block.start)-\(.best_block.end) (\(.best_block.duration_min)min)" else "" end)
      ' /tmp/lb_rpt.json
      echo ""
      echo "ðŸ¤– LLM Schedule Insights"
      echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      echo "$LLM_DATA" | jq -r '
        "\nðŸ“‹ Block Assignments:" +
        (.block_assignments | if type == "array" then map("\n  â€¢ " + .) | join("") elif type == "object" then to_entries | map("\n  â€¢ \(.key): \(.value)") | join("") else "\n  \(.)" end) +
        "\n\nðŸ”„ Async Candidates:" +
        (.async_candidates | if type == "array" then map("\n  â€¢ " + (if type == "object" then "\(.meeting // .name): \(.reasoning // .reason)" else tostring end)) | join("") else "\n  \(.)" end) +
        "\n\nðŸ’¡ Schedule Tweaks:" +
        (.schedule_tweaks | if type == "array" then map("\n  â€¢ " + tostring) | join("") else "\n  \(.)" end) +
        "\n\nâ­ Deep Work Score: \(.deep_work_score)/10" +
        "\n\nðŸŽ¯ Maker vs Manager:\n  \(.maker_vs_manager)"
      ' 2>/dev/null || echo "$LLM_DATA"
      rm -f /tmp/lb_rpt.json /tmp/lb_blocks.json
