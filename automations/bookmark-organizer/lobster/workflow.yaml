# Lobster workflow: bookmark-organizer
# Reads a markdown bookmarks file, checks for dead links, and produces
# a categorized report
#
# Usage:
#   lobster run --file workflow.yaml --args-json '{"bookmarks_path":"/data/clawd/bookmarks.md"}'
#
# Requires: jq, curl
# LLM: Uses prompt step for bookmark categorization

name: bookmark-organizer
description: Periodically organize and summarize your saved bookmarks/links

args:
  bookmarks_path:
    description: "Path to bookmarks file (markdown with ## categories and [title](url) links)"
    default: "/data/clawd/bookmarks.md"
  max_process:
    description: "Max bookmarks to process per run"
    default: "20"
  check_dead_links:
    description: "Check for dead/moved links (true/false)"
    default: "true"

steps:
  - id: read-bookmarks
    command: |
      if [ ! -f "${bookmarks_path}" ]; then
        echo "No bookmarks file found at ${bookmarks_path}. Creating empty template." >&2
        echo '{"bookmarks":[],"categories":[],"total":0}'
        exit 0
      fi
      cat "${bookmarks_path}"

  - id: parse-bookmarks
    stdin: $read-bookmarks.stdout
    command: |
      cat > /tmp/lb_bo_raw.md
      max="${max_process}"

      # Check if input is already JSON (empty file case)
      if head -1 /tmp/lb_bo_raw.md | grep -q '^{'; then
        cat /tmp/lb_bo_raw.md
        rm -f /tmp/lb_bo_raw.md
        exit 0
      fi

      # Parse markdown bookmarks: extract categories and links
      python3 -c "
      import json, re, sys

      content = open('/tmp/lb_bo_raw.md').read()
      lines = content.split('\n')
      bookmarks = []
      category = 'Uncategorized'
      for line in lines:
          if line.startswith('## '):
              category = line[3:].strip()
          else:
              m = re.search(r'\[([^\]]+)\]\((https?://[^)]+)\)', line)
              if m:
                  bookmarks.append({'title': m.group(1), 'url': m.group(2), 'category': category})

      max_n = int('${max_process}') if '${max_process}'.isdigit() else 20
      bookmarks = bookmarks[:max_n]
      cats = list(set(b['category'] for b in bookmarks))
      print(json.dumps({'bookmarks': bookmarks, 'categories': sorted(cats), 'total': len(bookmarks)}))
      " 2>/dev/null || echo '{"bookmarks":[],"categories":[],"total":0}'
      rm -f /tmp/lb_bo_raw.md

  - id: check-links
    stdin: $parse-bookmarks.stdout
    command: |
      cat > /tmp/lb_bo_parsed.json
      check="${check_dead_links}"

      if [ "$check" != "true" ]; then
        jq '{bookmarks: .bookmarks, categories: .categories, total: .total, dead_links: [], checked: false}' /tmp/lb_bo_parsed.json
        rm -f /tmp/lb_bo_parsed.json
        exit 0
      fi

      # Check each URL with a HEAD request (timeout 5s)
      dead="[]"
      urls=$(jq -r '.bookmarks[].url' /tmp/lb_bo_parsed.json)
      tmpd=/tmp/lb_bo_dead.json
      echo '[]' > "$tmpd"

      for url in $urls; do
        status=$(curl -o /dev/null -s -w '%{http_code}' --max-time 5 -L "$url" 2>/dev/null)
        status=${status:-000}
        if [ "$status" = "000" ] || [ "$status" -ge 400 ] 2>/dev/null; then
          title=$(jq -r --arg u "$url" '.bookmarks[] | select(.url==$u) | .title' /tmp/lb_bo_parsed.json | head -1)
          jq --arg u "$url" --arg t "$title" --argjson s "$status" '. + [{url:$u, title:$t, status:$s}]' "$tmpd" > /tmp/lb_bo_dead2.json
          mv /tmp/lb_bo_dead2.json "$tmpd"
        fi
      done

      jq --slurpfile dead "$tmpd" '{
        bookmarks: .bookmarks,
        categories: .categories,
        total: .total,
        dead_links: $dead[0],
        checked: true
      }' /tmp/lb_bo_parsed.json
      rm -f /tmp/lb_bo_parsed.json "$tmpd"

  - id: generate-summary
    stdin: $check-links.stdout
    command: |
      # Produce summary stats and categorization data
      cat > /tmp/lb_bo_checked.json

      jq '{
        total: .total,
        categories: (
          [.bookmarks | group_by(.category)[] |
            {category: .[0].category, count: length, items: [.[].title]}]
        ),
        uncategorized: [.bookmarks[] | select(.category == "Uncategorized") | {title, url}],
        dead_links: .dead_links,
        checked: .checked,
        needs_categorization: ([.bookmarks[] | select(.category == "Uncategorized")] | length),
        health: {
          total_checked: .total,
          dead: (.dead_links | length),
          alive: (.total - (.dead_links | length))
        }
      }' /tmp/lb_bo_checked.json
      rm -f /tmp/lb_bo_checked.json

  - id: categorize-and-report
    stdin: $generate-summary.stdout
    command: |
      llm_task.invoke --prompt "SYSTEM: You are a knowledge management assistant. Organize bookmarks into clear, useful categories.\n\nUSER: Analyze the bookmark collection data below and produce an organized report.\n\nTasks:\n1. For any uncategorized bookmarks, suggest appropriate categories based on their titles and URLs (e.g., Development, Design, AI/ML, Business, DevOps, Learning, etc.)\n2. Identify duplicate or very similar bookmarks\n3. Suggest a reorganization plan if categories are imbalanced\n4. Flag any bookmarks with dead links for removal\n5. Format as a clean, scannable report with emoji category headers\n\nData:\n$(cat)"
    env:
      CLAWD_URL: "http://127.0.0.1:3000"

